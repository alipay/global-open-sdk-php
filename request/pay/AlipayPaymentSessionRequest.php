<?php

/**
 * payments_createPaymentSession
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


namespace Request\pay;

use \ArrayAccess;
use Request\AlipayRequest;
use Model\ModelInterface;
use Model\ObjectSerializer;

/**
 * AlipayPaymentSessionRequest Class Doc Comment
 *
 * @category Class
 * @package  request
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class AlipayPaymentSessionRequest   extends AlipayRequest  implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'AlipayPaymentSessionRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'productCode' => '\request\model\ProductCodeType',
        'paymentRequestId' => 'string',
        'order' => '\request\model\Order',
        'paymentAmount' => '\request\model\Amount',
        'paymentMethod' => '\request\model\PaymentMethod',
        'paymentSessionExpiryTime' => 'string',
        'paymentRedirectUrl' => 'string',
        'paymentNotifyUrl' => 'string',
        'paymentFactor' => '\request\model\PaymentFactor',
        'settlementStrategy' => '\request\model\SettlementStrategy',
        'enableInstallmentCollection' => 'bool',
        'creditPayPlan' => '\request\model\CreditPayPlan',
        'merchantRegion' => 'string',
        'env' => '\request\model\Env',
        'agreementInfo' => '\request\model\AgreementInfo',
        'riskData' => '\request\model\RiskData',
        'productScene' => 'string',
        'savedPaymentMethods' => '\request\model\PaymentMethod[]',
        'locale' => 'string',
        'availablePaymentMethod' => '\request\model\AvailablePaymentMethod',
        'testFile' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'productCode' => null,
        'paymentRequestId' => null,
        'order' => null,
        'paymentAmount' => null,
        'paymentMethod' => null,
        'paymentSessionExpiryTime' => null,
        'paymentRedirectUrl' => null,
        'paymentNotifyUrl' => null,
        'paymentFactor' => null,
        'settlementStrategy' => null,
        'enableInstallmentCollection' => null,
        'creditPayPlan' => null,
        'merchantRegion' => null,
        'env' => null,
        'agreementInfo' => null,
        'riskData' => null,
        'productScene' => null,
        'savedPaymentMethods' => null,
        'locale' => null,
        'availablePaymentMethod' => null,
        'testFile' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static $openAPINullables = [
        'productCode' => false,
        'paymentRequestId' => false,
        'order' => false,
        'paymentAmount' => false,
        'paymentMethod' => false,
        'paymentSessionExpiryTime' => false,
        'paymentRedirectUrl' => false,
        'paymentNotifyUrl' => false,
        'paymentFactor' => false,
        'settlementStrategy' => false,
        'enableInstallmentCollection' => false,
        'creditPayPlan' => false,
        'merchantRegion' => false,
        'env' => false,
        'agreementInfo' => false,
        'riskData' => false,
        'productScene' => false,
        'savedPaymentMethods' => false,
        'locale' => false,
        'availablePaymentMethod' => false,
        'testFile' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'productCode' => 'productCode',
        'paymentRequestId' => 'paymentRequestId',
        'order' => 'order',
        'paymentAmount' => 'paymentAmount',
        'paymentMethod' => 'paymentMethod',
        'paymentSessionExpiryTime' => 'paymentSessionExpiryTime',
        'paymentRedirectUrl' => 'paymentRedirectUrl',
        'paymentNotifyUrl' => 'paymentNotifyUrl',
        'paymentFactor' => 'paymentFactor',
        'settlementStrategy' => 'settlementStrategy',
        'enableInstallmentCollection' => 'enableInstallmentCollection',
        'creditPayPlan' => 'creditPayPlan',
        'merchantRegion' => 'merchantRegion',
        'env' => 'env',
        'agreementInfo' => 'agreementInfo',
        'riskData' => 'riskData',
        'productScene' => 'productScene',
        'savedPaymentMethods' => 'savedPaymentMethods',
        'locale' => 'locale',
        'availablePaymentMethod' => 'availablePaymentMethod',
        'testFile' => 'testFile'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'productCode' => 'setProductCode',
        'paymentRequestId' => 'setPaymentRequestId',
        'order' => 'setOrder',
        'paymentAmount' => 'setPaymentAmount',
        'paymentMethod' => 'setPaymentMethod',
        'paymentSessionExpiryTime' => 'setPaymentSessionExpiryTime',
        'paymentRedirectUrl' => 'setPaymentRedirectUrl',
        'paymentNotifyUrl' => 'setPaymentNotifyUrl',
        'paymentFactor' => 'setPaymentFactor',
        'settlementStrategy' => 'setSettlementStrategy',
        'enableInstallmentCollection' => 'setEnableInstallmentCollection',
        'creditPayPlan' => 'setCreditPayPlan',
        'merchantRegion' => 'setMerchantRegion',
        'env' => 'setEnv',
        'agreementInfo' => 'setAgreementInfo',
        'riskData' => 'setRiskData',
        'productScene' => 'setProductScene',
        'savedPaymentMethods' => 'setSavedPaymentMethods',
        'locale' => 'setLocale',
        'availablePaymentMethod' => 'setAvailablePaymentMethod',
        'testFile' => 'setTestFile'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'productCode' => 'getProductCode',
        'paymentRequestId' => 'getPaymentRequestId',
        'order' => 'getOrder',
        'paymentAmount' => 'getPaymentAmount',
        'paymentMethod' => 'getPaymentMethod',
        'paymentSessionExpiryTime' => 'getPaymentSessionExpiryTime',
        'paymentRedirectUrl' => 'getPaymentRedirectUrl',
        'paymentNotifyUrl' => 'getPaymentNotifyUrl',
        'paymentFactor' => 'getPaymentFactor',
        'settlementStrategy' => 'getSettlementStrategy',
        'enableInstallmentCollection' => 'getEnableInstallmentCollection',
        'creditPayPlan' => 'getCreditPayPlan',
        'merchantRegion' => 'getMerchantRegion',
        'env' => 'getEnv',
        'agreementInfo' => 'getAgreementInfo',
        'riskData' => 'getRiskData',
        'productScene' => 'getProductScene',
        'savedPaymentMethods' => 'getSavedPaymentMethods',
        'locale' => 'getLocale',
        'availablePaymentMethod' => 'getAvailablePaymentMethod',
        'testFile' => 'getTestFile'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('productCode', $data ?? [], null);
        $this->setIfExists('paymentRequestId', $data ?? [], null);
        $this->setIfExists('order', $data ?? [], null);
        $this->setIfExists('paymentAmount', $data ?? [], null);
        $this->setIfExists('paymentMethod', $data ?? [], null);
        $this->setIfExists('paymentSessionExpiryTime', $data ?? [], null);
        $this->setIfExists('paymentRedirectUrl', $data ?? [], null);
        $this->setIfExists('paymentNotifyUrl', $data ?? [], null);
        $this->setIfExists('paymentFactor', $data ?? [], null);
        $this->setIfExists('settlementStrategy', $data ?? [], null);
        $this->setIfExists('enableInstallmentCollection', $data ?? [], null);
        $this->setIfExists('creditPayPlan', $data ?? [], null);
        $this->setIfExists('merchantRegion', $data ?? [], null);
        $this->setIfExists('env', $data ?? [], null);
        $this->setIfExists('agreementInfo', $data ?? [], null);
        $this->setIfExists('riskData', $data ?? [], null);
        $this->setIfExists('productScene', $data ?? [], null);
        $this->setIfExists('savedPaymentMethods', $data ?? [], null);
        $this->setIfExists('locale', $data ?? [], null);
        $this->setIfExists('availablePaymentMethod', $data ?? [], null);
        $this->setIfExists('testFile', $data ?? [], null);

         $this->setPath("/ams/api/v1/payments/createPaymentSession"); 
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['productCode'] === null) {
            $invalidProperties[] = "'productCode' can't be null";
        }
        if ($this->container['paymentRequestId'] === null) {
            $invalidProperties[] = "'paymentRequestId' can't be null";
        }
        if ($this->container['order'] === null) {
            $invalidProperties[] = "'order' can't be null";
        }
        if ($this->container['paymentAmount'] === null) {
            $invalidProperties[] = "'paymentAmount' can't be null";
        }
        if ($this->container['paymentMethod'] === null) {
            $invalidProperties[] = "'paymentMethod' can't be null";
        }
        if ($this->container['paymentRedirectUrl'] === null) {
            $invalidProperties[] = "'paymentRedirectUrl' can't be null";
        }
        if ($this->container['settlementStrategy'] === null) {
            $invalidProperties[] = "'settlementStrategy' can't be null";
        }
        if ($this->container['testFile'] === null) {
            $invalidProperties[] = "'testFile' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets productCode
     *
     * @return string
     */
    public function getProductCode()
    {
        return $this->container['productCode'];
    }

    /**
     * Sets productCode
     *
     * @param string $productCode productCode
     *
     * @return self
     */
    public function setProductCode($productCode)
    {
        $this->container['productCode'] = $productCode;

        return $this;
    }

    /**
     * Gets paymentRequestId
     *
     * @return string
     */
    public function getPaymentRequestId()
    {
        return $this->container['paymentRequestId'];
    }

    /**
     * Sets paymentRequestId
     *
     * @param string $paymentRequestId The unique ID assigned by a merchant to identify a payment request.   More information:  Maximum length: 64 characters
     *
     * @return self
     */
    public function setPaymentRequestId($paymentRequestId)
    {
        $this->container['paymentRequestId'] = $paymentRequestId;

        return $this;
    }

    /**
     * Gets order
     *
     * @return \model\Order
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param \model\Order $order order
     *
     * @return self
     */
    public function setOrder($order)
    {
        $this->container['order'] = $order;

        return $this;
    }

    /**
     * Gets paymentAmount
     *
     * @return \model\Amount
     */
    public function getPaymentAmount()
    {
        return $this->container['paymentAmount'];
    }

    /**
     * Sets paymentAmount
     *
     * @param \model\Amount $paymentAmount paymentAmount
     *
     * @return self
     */
    public function setPaymentAmount($paymentAmount)
    {
        $this->container['paymentAmount'] = $paymentAmount;

        return $this;
    }

    /**
     * Gets paymentMethod
     *
     * @return \model\PaymentMethod
     */
    public function getPaymentMethod()
    {
        return $this->container['paymentMethod'];
    }

    /**
     * Sets paymentMethod
     *
     * @param \model\PaymentMethod $paymentMethod paymentMethod
     *
     * @return self
     */
    public function setPaymentMethod($paymentMethod)
    {
        $this->container['paymentMethod'] = $paymentMethod;

        return $this;
    }

    /**
     * Gets paymentSessionExpiryTime
     *
     * @return string|null
     */
    public function getPaymentSessionExpiryTime()
    {
        return $this->container['paymentSessionExpiryTime'];
    }

    /**
     * Sets paymentSessionExpiryTime
     *
     * @param string|null $paymentSessionExpiryTime The specific date and time after which the payment session will expire. The default expiration time is 1 hour after the session creation. For example, if the session is created at 2023-7-27T12:00:01+08:30, the session expiration time is 2023-7-27T13:00:01+08:30.  Specify this parameter if you want to use a payment session expiration time that differs from the default time. The specified expiration time must be 0 to 1 hour after session creation.    More information:  The value follows the ISO 8601 standard format. For example, \"2019-11-27T12:01:01+08:00\".
     *
     * @return self
     */
    public function setPaymentSessionExpiryTime($paymentSessionExpiryTime)
    {
        $this->container['paymentSessionExpiryTime'] = $paymentSessionExpiryTime;

        return $this;
    }

    /**
     * Gets paymentRedirectUrl
     *
     * @return string
     */
    public function getPaymentRedirectUrl()
    {
        return $this->container['paymentRedirectUrl'];
    }

    /**
     * Sets paymentRedirectUrl
     *
     * @param string $paymentRedirectUrl The merchant page URL that the user is redirected to after the payment is completed.  More information:  Maximum length: 2048 characters
     *
     * @return self
     */
    public function setPaymentRedirectUrl($paymentRedirectUrl)
    {
        $this->container['paymentRedirectUrl'] = $paymentRedirectUrl;

        return $this;
    }

    /**
     * Gets paymentNotifyUrl
     *
     * @return string|null
     */
    public function getPaymentNotifyUrl()
    {
        return $this->container['paymentNotifyUrl'];
    }

    /**
     * Sets paymentNotifyUrl
     *
     * @param string|null $paymentNotifyUrl The URL that is used to receive the payment result notification.  Specify this parameter if you want to receive an asynchronous notification of the payment result. You can also set the URL to receive the result notification in Antom Dashboard. If the URL is specified in both the request and Antom Dashboard, the value specified in the request takes precedence.  More information:  Maximum length: 2048 characters
     *
     * @return self
     */
    public function setPaymentNotifyUrl($paymentNotifyUrl)
    {
        $this->container['paymentNotifyUrl'] = $paymentNotifyUrl;

        return $this;
    }

    /**
     * Gets paymentFactor
     *
     * @return \model\PaymentFactor|null
     */
    public function getPaymentFactor()
    {
        return $this->container['paymentFactor'];
    }

    /**
     * Sets paymentFactor
     *
     * @param \model\PaymentFactor|null $paymentFactor paymentFactor
     *
     * @return self
     */
    public function setPaymentFactor($paymentFactor)
    {
        $this->container['paymentFactor'] = $paymentFactor;

        return $this;
    }

    /**
     * Gets settlementStrategy
     *
     * @return \model\SettlementStrategy
     */
    public function getSettlementStrategy()
    {
        return $this->container['settlementStrategy'];
    }

    /**
     * Sets settlementStrategy
     *
     * @param \model\SettlementStrategy $settlementStrategy settlementStrategy
     *
     * @return self
     */
    public function setSettlementStrategy($settlementStrategy)
    {
        $this->container['settlementStrategy'] = $settlementStrategy;

        return $this;
    }

    /**
     * Gets enableInstallmentCollection
     *
     * @return bool|null
     */
    public function getEnableInstallmentCollection()
    {
        return $this->container['enableInstallmentCollection'];
    }

    /**
     * Sets enableInstallmentCollection
     *
     * @param bool|null $enableInstallmentCollection Indicates whether Antom collects the installment information for the payment. Specify this parameter if you need Antom to collect the installment information. Valid values are:  true: indicates Antom collects installment information when the user's card supports installments. Installments are not available when the user's card does not support installments. false: indicates you do not need Antom to collect the installment information. The same applies when the value is empty or you do not specify this parameter.
     *
     * @return self
     */
    public function setEnableInstallmentCollection($enableInstallmentCollection)
    {
        $this->container['enableInstallmentCollection'] = $enableInstallmentCollection;

        return $this;
    }

    /**
     * Gets creditPayPlan
     *
     * @return \model\CreditPayPlan|null
     */
    public function getCreditPayPlan()
    {
        return $this->container['creditPayPlan'];
    }

    /**
     * Sets creditPayPlan
     *
     * @param \model\CreditPayPlan|null $creditPayPlan creditPayPlan
     *
     * @return self
     */
    public function setCreditPayPlan($creditPayPlan)
    {
        $this->container['creditPayPlan'] = $creditPayPlan;

        return $this;
    }

    /**
     * Gets merchantRegion
     *
     * @return string|null
     */
    public function getMerchantRegion()
    {
        return $this->container['merchantRegion'];
    }

    /**
     * Sets merchantRegion
     *
     * @param string|null $merchantRegion The country or region where the merchant operates the business. The parameter is a 2-letter country or region code that follows ISO 3166 Country Codes standard.  Some possible values are US, SG, HK, PK, JP, CN, BR, AU, and MY.    Note: This parameter is required when you use the Global Acquirer Gateway (GAGW) product.  More information:  Maximum length: 2 characters
     *
     * @return self
     */
    public function setMerchantRegion($merchantRegion)
    {
        $this->container['merchantRegion'] = $merchantRegion;

        return $this;
    }

    /**
     * Gets env
     *
     * @return \model\Env|null
     */
    public function getEnv()
    {
        return $this->container['env'];
    }

    /**
     * Sets env
     *
     * @param \model\Env|null $env env
     *
     * @return self
     */
    public function setEnv($env)
    {
        $this->container['env'] = $env;

        return $this;
    }

    /**
     * Gets agreementInfo
     *
     * @return \model\AgreementInfo|null
     */
    public function getAgreementInfo()
    {
        return $this->container['agreementInfo'];
    }

    /**
     * Sets agreementInfo
     *
     * @param \model\AgreementInfo|null $agreementInfo agreementInfo
     *
     * @return self
     */
    public function setAgreementInfo($agreementInfo)
    {
        $this->container['agreementInfo'] = $agreementInfo;

        return $this;
    }

    /**
     * Gets riskData
     *
     * @return \model\RiskData|null
     */
    public function getRiskData()
    {
        return $this->container['riskData'];
    }

    /**
     * Sets riskData
     *
     * @param \model\RiskData|null $riskData riskData
     *
     * @return self
     */
    public function setRiskData($riskData)
    {
        $this->container['riskData'] = $riskData;

        return $this;
    }

    /**
     * Gets productScene
     *
     * @return string|null
     */
    public function getProductScene()
    {
        return $this->container['productScene'];
    }

    /**
     * Sets productScene
     *
     * @param string|null $productScene Specified product scenarios include valid values:  ​CHECKOUT_PAYMENT​: Indicates that the merchant integrates using the Checkout Page. ​ELEMENT_PAYMENT​: Indicates that the merchant integrates using the Element. More information:  Maximum length: 32 characters
     *
     * @return self
     */
    public function setProductScene($productScene)
    {
        $this->container['productScene'] = $productScene;

        return $this;
    }

    /**
     * Gets savedPaymentMethods
     *
     * @return \model\PaymentMethod[]|null
     */
    public function getSavedPaymentMethods()
    {
        return $this->container['savedPaymentMethods'];
    }

    /**
     * Sets savedPaymentMethods
     *
     * @param \model\PaymentMethod[]|null $savedPaymentMethods Payment information stored by the user in the merchant system.
     *
     * @return self
     */
    public function setSavedPaymentMethods($savedPaymentMethods)
    {
        $this->container['savedPaymentMethods'] = $savedPaymentMethods;

        return $this;
    }

    /**
     * Gets locale
     *
     * @return string|null
     */
    public function getLocale()
    {
        return $this->container['locale'];
    }

    /**
     * Sets locale
     *
     * @param string|null $locale Language tag specified for the Checkout Page. If this field is empty or set to automatic, the default language setting of the browser will be used, which is usually English.  More information:  Maximum length: 8 characters
     *
     * @return self
     */
    public function setLocale($locale)
    {
        $this->container['locale'] = $locale;

        return $this;
    }

    /**
     * Gets availablePaymentMethod
     *
     * @return \model\AvailablePaymentMethod|null
     */
    public function getAvailablePaymentMethod()
    {
        return $this->container['availablePaymentMethod'];
    }

    /**
     * Sets availablePaymentMethod
     *
     * @param \model\AvailablePaymentMethod|null $availablePaymentMethod availablePaymentMethod
     *
     * @return self
     */
    public function setAvailablePaymentMethod($availablePaymentMethod)
    {
        $this->container['availablePaymentMethod'] = $availablePaymentMethod;

        return $this;
    }

    /**
     * Gets testFile
     *
     * @return string
     */
    public function getTestFile()
    {
        return $this->container['testFile'];
    }

    /**
     * Sets testFile
     *
     * @param string $testFile testFile
     *
     * @return self
     */
    public function setTestFile($testFile)
    {
        $this->container['testFile'] = $testFile;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return ObjectSerializer::sanitizeForSerialization($this);
    }

    public function toArray(): array
    {
        $array = [];
        foreach (self::$openAPITypes as $propertyName => $propertyType) {
            $propertyValue = $this[$propertyName];
            if ($propertyValue !== null) {
                // Check if the property value is an object and has a toArray() method
                if (is_object($propertyValue) && method_exists($propertyValue, 'toArray')) {
                    $array[$propertyName] = $propertyValue->toArray();
                // Check if it's type datetime
                } elseif ($propertyValue instanceof \DateTime) {
                    $array[$propertyName] = $propertyValue->format(DATE_ATOM);
                // If it's an array type we should check whether it contains objects and if so call toArray method
                } elseif (is_array($propertyValue)) {
                    $array[$propertyName] = array_map(function ($item) {
                        return $item instanceof ModelInterface ? $item->toArray() : $item;
                    }, $propertyValue);
                } else {
                    // Otherwise, directly assign the property value to the array
                    $array[$propertyName] = $propertyValue;
                }
            }
        }
        return $array;
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }
}
