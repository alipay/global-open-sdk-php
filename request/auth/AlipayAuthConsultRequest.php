<?php

/**
 * authorizations_consult
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


namespace Request\auth;

use \ArrayAccess;
use Request\AlipayRequest;
use Model\ModelInterface;
use Model\ObjectSerializer;

/**
 * AlipayAuthConsultRequest Class Doc Comment
 *
 * @category Class
 * @package  request
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class AlipayAuthConsultRequest   extends AlipayRequest  implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'AlipayAuthConsultRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'customerBelongsTo' => '\request\model\CustomerBelongsTo',
        'authClientId' => 'string',
        'authRedirectUrl' => 'string',
        'scopes' => '\request\model\ScopeType[]',
        'authState' => 'string',
        'terminalType' => '\request\model\TerminalType',
        'osType' => '\request\model\OsType',
        'osVersion' => 'string',
        'extendInfo' => 'string',
        'merchantRegion' => 'string',
        'recurringPayment' => 'bool',
        'authMetaData' => '\request\model\AuthMetaData'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'customerBelongsTo' => null,
        'authClientId' => null,
        'authRedirectUrl' => null,
        'scopes' => null,
        'authState' => null,
        'terminalType' => null,
        'osType' => null,
        'osVersion' => null,
        'extendInfo' => null,
        'merchantRegion' => null,
        'recurringPayment' => null,
        'authMetaData' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static $openAPINullables = [
        'customerBelongsTo' => false,
        'authClientId' => false,
        'authRedirectUrl' => false,
        'scopes' => false,
        'authState' => false,
        'terminalType' => false,
        'osType' => false,
        'osVersion' => false,
        'extendInfo' => false,
        'merchantRegion' => false,
        'recurringPayment' => false,
        'authMetaData' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'customerBelongsTo' => 'customerBelongsTo',
        'authClientId' => 'authClientId',
        'authRedirectUrl' => 'authRedirectUrl',
        'scopes' => 'scopes',
        'authState' => 'authState',
        'terminalType' => 'terminalType',
        'osType' => 'osType',
        'osVersion' => 'osVersion',
        'extendInfo' => 'extendInfo',
        'merchantRegion' => 'merchantRegion',
        'recurringPayment' => 'recurringPayment',
        'authMetaData' => 'authMetaData'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'customerBelongsTo' => 'setCustomerBelongsTo',
        'authClientId' => 'setAuthClientId',
        'authRedirectUrl' => 'setAuthRedirectUrl',
        'scopes' => 'setScopes',
        'authState' => 'setAuthState',
        'terminalType' => 'setTerminalType',
        'osType' => 'setOsType',
        'osVersion' => 'setOsVersion',
        'extendInfo' => 'setExtendInfo',
        'merchantRegion' => 'setMerchantRegion',
        'recurringPayment' => 'setRecurringPayment',
        'authMetaData' => 'setAuthMetaData'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'customerBelongsTo' => 'getCustomerBelongsTo',
        'authClientId' => 'getAuthClientId',
        'authRedirectUrl' => 'getAuthRedirectUrl',
        'scopes' => 'getScopes',
        'authState' => 'getAuthState',
        'terminalType' => 'getTerminalType',
        'osType' => 'getOsType',
        'osVersion' => 'getOsVersion',
        'extendInfo' => 'getExtendInfo',
        'merchantRegion' => 'getMerchantRegion',
        'recurringPayment' => 'getRecurringPayment',
        'authMetaData' => 'getAuthMetaData'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('customerBelongsTo', $data ?? [], null);
        $this->setIfExists('authClientId', $data ?? [], null);
        $this->setIfExists('authRedirectUrl', $data ?? [], null);
        $this->setIfExists('scopes', $data ?? [], null);
        $this->setIfExists('authState', $data ?? [], null);
        $this->setIfExists('terminalType', $data ?? [], null);
        $this->setIfExists('osType', $data ?? [], null);
        $this->setIfExists('osVersion', $data ?? [], null);
        $this->setIfExists('extendInfo', $data ?? [], null);
        $this->setIfExists('merchantRegion', $data ?? [], null);
        $this->setIfExists('recurringPayment', $data ?? [], null);
        $this->setIfExists('authMetaData', $data ?? [], null);

         $this->setPath("/ams/api/v1/authorizations/consult"); 
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['customerBelongsTo'] === null) {
            $invalidProperties[] = "'customerBelongsTo' can't be null";
        }
        if ($this->container['authRedirectUrl'] === null) {
            $invalidProperties[] = "'authRedirectUrl' can't be null";
        }
        if ($this->container['scopes'] === null) {
            $invalidProperties[] = "'scopes' can't be null";
        }
        if ($this->container['authState'] === null) {
            $invalidProperties[] = "'authState' can't be null";
        }
        if ($this->container['terminalType'] === null) {
            $invalidProperties[] = "'terminalType' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets customerBelongsTo
     *
     * @return \request\model\CustomerBelongsTo
     */
    public function getCustomerBelongsTo()
    {
        return $this->container['customerBelongsTo'];
    }

    /**
     * Sets customerBelongsTo
     *
     * @param \request\model\CustomerBelongsTo $customerBelongsTo customerBelongsTo
     *
     * @return self
     */
    public function setCustomerBelongsTo($customerBelongsTo)
    {
        $this->container['customerBelongsTo'] = $customerBelongsTo;

        return $this;
    }

    /**
     * Gets authClientId
     *
     * @return string|null
     */
    public function getAuthClientId()
    {
        return $this->container['authClientId'];
    }

    /**
     * Sets authClientId
     *
     * @param string|null $authClientId The unique ID of the secondary merchant to which the user grants resource access permission. The value is specified by the acquirer and needs to be registered in Antom.    Notes:   Specify this field if you are an acquirer with secondary merchants. For an Alipay+ payment methods, the value of this field is the same as the value of the referenceMerchantId field in the pay (Auto Debit) interface. More information:  Maximum length: 64 characters
     *
     * @return self
     */
    public function setAuthClientId($authClientId)
    {
        $this->container['authClientId'] = $authClientId;

        return $this;
    }

    /**
     * Gets authRedirectUrl
     *
     * @return string
     */
    public function getAuthRedirectUrl()
    {
        return $this->container['authRedirectUrl'];
    }

    /**
     * Sets authRedirectUrl
     *
     * @param string $authRedirectUrl The redirection URL that the user is redirected to after the user agrees to authorize. This value is provided by the merchant.  More information:  Maximum length: 1024 characters
     *
     * @return self
     */
    public function setAuthRedirectUrl($authRedirectUrl)
    {
        $this->container['authRedirectUrl'] = $authRedirectUrl;

        return $this;
    }

    /**
     * Gets scopes
     *
     * @return \request\model\ScopeType[]
     */
    public function getScopes()
    {
        return $this->container['scopes'];
    }

    /**
     * Sets scopes
     *
     * @param \request\model\ScopeType[] $scopes The authorization scope. Valid values are:    BASE_USER_INFO: Indicates that the unique user ID can be obtained. USER_INFO: Indicates that the complete user information can be obtained, for example, user name, avatar, and other user information. AGREEMENT_PAY: Indicates that the user agrees to authorize for auto debit so that the merchant can use the access token to automatically deduct money from the user's account. More information:  Maximum size: 4 elements
     *
     * @return self
     */
    public function setScopes($scopes)
    {
        $this->container['scopes'] = $scopes;

        return $this;
    }

    /**
     * Gets authState
     *
     * @return string
     */
    public function getAuthState()
    {
        return $this->container['authState'];
    }

    /**
     * Sets authState
     *
     * @param string $authState The unique ID generated by the merchant to represent the consult request. The consistency of this field and that in the redirection URL when the user agrees to authorize needs to be guaranteed.  More information:  Maximum length: 256 characters
     *
     * @return self
     */
    public function setAuthState($authState)
    {
        $this->container['authState'] = $authState;

        return $this;
    }

    /**
     * Gets terminalType
     *
     * @return \request\model\TerminalType
     */
    public function getTerminalType()
    {
        return $this->container['terminalType'];
    }

    /**
     * Sets terminalType
     *
     * @param \request\model\TerminalType $terminalType terminalType
     *
     * @return self
     */
    public function setTerminalType($terminalType)
    {
        $this->container['terminalType'] = $terminalType;

        return $this;
    }

    /**
     * Gets osType
     *
     * @return \request\model\OsType|null
     */
    public function getOsType()
    {
        return $this->container['osType'];
    }

    /**
     * Sets osType
     *
     * @param \request\model\OsType|null $osType osType
     *
     * @return self
     */
    public function setOsType($osType)
    {
        $this->container['osType'] = $osType;

        return $this;
    }

    /**
     * Gets osVersion
     *
     * @return string|null
     */
    public function getOsVersion()
    {
        return $this->container['osVersion'];
    }

    /**
     * Sets osVersion
     *
     * @param string|null $osVersion The OS version.   Note: Specify this parameter when the value of terminalType is APP or WAP and you have this information. Providing this information makes the user's payment experience better.  More information:  Maximum length: 16 characters
     *
     * @return self
     */
    public function setOsVersion($osVersion)
    {
        $this->container['osVersion'] = $osVersion;

        return $this;
    }

    /**
     * Gets extendInfo
     *
     * @return string|null
     */
    public function getExtendInfo()
    {
        return $this->container['extendInfo'];
    }

    /**
     * Sets extendInfo
     *
     * @param string|null $extendInfo extendInfo
     *
     * @return self
     */
    public function setExtendInfo($extendInfo)
    {
        $this->container['extendInfo'] = $extendInfo;

        return $this;
    }

    /**
     * Gets merchantRegion
     *
     * @return string|null
     */
    public function getMerchantRegion()
    {
        return $this->container['merchantRegion'];
    }

    /**
     * Sets merchantRegion
     *
     * @param string|null $merchantRegion The country or region where the merchant or secondary merchant operates the business. The parameter is a 2-letter country/region code that follows ISO 3166 Country Codes standard. Only US, JP, PK, SG are supported now.  Note: This field is required when you use the Global Acquirer Gateway (GAGW) product.  More information:  Maximum length: 2 characters
     *
     * @return self
     */
    public function setMerchantRegion($merchantRegion)
    {
        $this->container['merchantRegion'] = $merchantRegion;

        return $this;
    }

    /**
     * Gets recurringPayment
     *
     * @return bool|null
     */
    public function getRecurringPayment()
    {
        return $this->container['recurringPayment'];
    }

    /**
     * Sets recurringPayment
     *
     * @param bool|null $recurringPayment Indicates whether the auto debit is used for recurring payments. Valid values are:  true: indicates the auto debit is for recurring payments. false: indicates the auto debit is not for recurring payments. Specify this parameter when the value of customerBelongsTo is PAYPAY.
     *
     * @return self
     */
    public function setRecurringPayment($recurringPayment)
    {
        $this->container['recurringPayment'] = $recurringPayment;

        return $this;
    }

    /**
     * Gets authMetaData
     *
     * @return \request\model\AuthMetaData|null
     */
    public function getAuthMetaData()
    {
        return $this->container['authMetaData'];
    }

    /**
     * Sets authMetaData
     *
     * @param \request\model\AuthMetaData|null $authMetaData authMetaData
     *
     * @return self
     */
    public function setAuthMetaData($authMetaData)
    {
        $this->container['authMetaData'] = $authMetaData;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
        return ObjectSerializer::sanitizeForSerialization($this);
    }

    public function toArray(): array
    {
        $array = [];
        foreach (self::$openAPITypes as $propertyName => $propertyType) {
            $propertyValue = $this[$propertyName];
            if ($propertyValue !== null) {
                // Check if the property value is an object and has a toArray() method
                if (is_object($propertyValue) && method_exists($propertyValue, 'toArray')) {
                    $array[$propertyName] = $propertyValue->toArray();
                // Check if it's type datetime
                } elseif ($propertyValue instanceof \DateTime) {
                    $array[$propertyName] = $propertyValue->format(DATE_ATOM);
                // If it's an array type we should check whether it contains objects and if so call toArray method
                } elseif (is_array($propertyValue)) {
                    $array[$propertyName] = array_map(function ($item) {
                        return $item instanceof ModelInterface ? $item->toArray() : $item;
                    }, $propertyValue);
                } else {
                    // Otherwise, directly assign the property value to the array
                    $array[$propertyName] = $propertyValue;
                }
            }
        }
        return $array;
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }
}
